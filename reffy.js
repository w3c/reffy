#!/usr/bin/env node
/**
 * Reffy's main command line interface that you can use to crawl and study spec
 * references.
 *
 * Reffy can be called directly through:
 *
 * `node reffy.js [command]`
 *
 * Run `node reffy.js -h` for help
 *
 * @module crawler
 */

const program = require('commander');
const version = require('./package.json').version;
const fs = require('fs');
const path = require('path');
const crawlSpecs = require('./src/cli/crawl-specs.js').crawlSpecs;
const studyCrawl = require('./src/cli/study-crawl.js').studyCrawl;
const generateReport = require('./src/cli/generate-report.js').generateReport;
const pandoc = require('node-pandoc');


// List of possible perspectives and associated parameters
// Note the "ed" perspective produces reports under "whatwg" for backward
// compatibility reason.
const perspectives = {
  'ed': {
    description: 'Crawls the latest Editor\'s Drafts',
    refStudy: 'https://w3c.github.io/webref/ed/study.json'
  },
  'tr': {
    description: 'Crawls the latest published versions of specifications in /TR/ space instead of the latest Editor\'s Drafts',
    publishedVersion: true,
    refStudy: 'https://w3c.github.io/webref/tr/study.json'
  }
};

// List of possible actions for each perspective
const possibleActions = {
  'all': 'crawl specs, study report and generate markdown, HTML and diff reports. Default action',
  'crawl': 'crawl specs and generate a machine-readable report with facts about each spec',
  'study': 'parse the machine-readable report generated by the crawler, and create a study report of potential anomalies found in the report',
  'markdown': 'produce a human-readable report in Markdown format out of the anomalies report returned by the study action',
  'html': 'produce an HTML report out of the Markdown report generated by the markdown action',
  'diff': 'compare the anomalies report with the latest published anomalies report and generate diff report',
  'diffnew': 'compare the anomalies report with the latest published anomalies report and generate diff report that only contains new anomalies'
};

let command = null; 
program
  .version(version)
  .option('-d, --debug', 'run crawl in debug mode (single process, one spec at a time)');

program
  .command('run <perspective> [action]')
  .description('run a new crawl and study from the given perspective')
  .option('-d, --debug', 'run crawl in debug mode (single process, one spec at a time)')
  .action(async (perspective, action, cmdObj) => {
    command = 'run';
    if (!(perspective in perspectives)) {
      return program.help();
    }
    if (action && !(action in possibleActions)) {
      return program.help();
    }

    let debug = cmdObj.debug || program.debug;
    let publishedVersion = perspectives[perspective].publishedVersion;
    let refStudy = perspectives[perspective].refStudy;
    let reportFolder = perspectives[perspective].reportFolder ||
      'reports/' + perspective;
    let crawlReport = path.join(reportFolder, 'index.json');
    let studyReport = path.join(reportFolder, 'study.json');

    let promise = Promise.resolve();
    let actions = (!action || (action === 'all')) ?
      ['crawl', 'study', 'markdown', 'html', 'diff', 'diffnew'] :
      [action];

    actions.forEach(action => {
      switch (action) {
      case 'crawl':
        promise = promise
          .then(_ => crawlSpecs(
            { publishedVersion, debug, output: reportFolder }));
        break;

      case 'study':
        const options = {};
        if (perspective === 'ed') {
          const trFolder = perspectives.tr.reportFolder || 'reports/tr';
          const trReport = path.join(trFolder, 'index.json');
          if (fs.existsSync(trReport)) {
            options.trResults = trReport;
          }
        }
        promise = promise
          .then(_ => studyCrawl(crawlReport, options))
          .then(results => {
            fs.writeFileSync(path.join(reportFolder, 'study.json'),
              JSON.stringify(results, null, 2));
          });
        break;

      case 'markdown':
        promise = promise
          .then(_ => generateReport(studyReport, { perSpec: true }))
          .then(report => fs.writeFileSync(path.join(reportFolder, 'index.md'), report))
          .then(_ => generateReport(studyReport, { perSpec: false }))
          .then(report => fs.writeFileSync(path.join(reportFolder, 'perissue.md'), report));
        break;

      case 'html':
        promise = promise
          .then(_ => new Promise((resolve, reject) => {
            let args = [
              '-f', 'markdown', '-t', 'html5', '--section-divs', '-s',
              '--template', path.join(__dirname, 'src', 'templates', 'report-template.html'),
              '-o', path.join(reportFolder, 'index.html')
            ];
            pandoc(path.join(reportFolder, 'index.md'), args,
              (err => {
                if (err) {
                  return reject(err);
                }
                args = [
                  '-f', 'markdown', '-t', 'html5', '--section-divs', '-s',
                  '--template', path.join(__dirname, 'src', 'templates', 'report-perissue-template.html'),
                  '-o', path.join(reportFolder, 'perissue.html')];
                pandoc(path.join(reportFolder, 'perissue.md'), args,
                  (err => {
                    if (err) {
                      return reject(err);
                    }
                    return resolve();
                  }));
              }));
            }));
        break;

      case 'diff':
        promise = promise
          .then(_ => generateReport(studyReport, {
            diffReport: true,
            refStudyFile: refStudy
          }))
          .then(report => fs.writeFileSync(path.join(reportFolder, 'diff.md'), report));
        break;

      case 'diffnew':
        promise = promise
          .then(_ => generateReport(studyReport, {
            diffReport: true,
            refStudyFile: refStudy,
            onlyNew: true
          }))
          .then(report => fs.writeFileSync(path.join(reportFolder, 'diffnew.md'), report));
        break;
      }
    });

    return promise;
  });

program.on('--help', function() {
  console.log('');
  console.log('  Possible perspectives:');
  console.log('');
  Object.keys(perspectives).forEach(perspective => {
    console.log('    ' + perspective + ': ' + perspectives[perspective].description);
  });
  console.log('');

  console.log('  Possible actions:');
  console.log('');
  Object.keys(possibleActions).forEach(action => {
    console.log('    ' + action + ': ' + possibleActions[action]);
  });
  console.log('');

  console.log('  Possible options:');
  console.log('');
  console.log('    -d, --debug: run crawl in debug mode (single process, one spec at a time)');
  console.log('');
});

program.on('command:*', function () {
  console.error('Invalid command: %s.\n', program.args.join(' '));
  program.outputHelp();
  process.exit(1);
});

if (!process.argv.slice(2).length) {
  console.error('Cannot run program without arguments.\n');
  program.outputHelp();
  process.exit(1);
}

program
  .parseAsync(process.argv)
  .then(_ => {
    console.log('-- THE END -- ');
    process.exit(0);
  })
  .catch(err => {
    console.error('-- ERROR CAUGHT --');
    console.error(err);
    process.exit(1);
  });
